#ifndef AUDIO_H
#define AUDIO_H

#ifdef __cplusplus
extern "C" {
#endif

#define AUDIO_MAX_MIDI_PLAYBACK_SPEED (0x0200)
#define AUDIO_MIN_MIDI_PLAYBACK_SPEED (0x0010)
#define AUDIO_X1_MIDI_PLAYBACK_SPEED (0x0100)

/*!
	\brief playback status
*/
typedef enum {
	AUDIO_PLAY_STOP = 0,
	AUDIO_PLAY_PAUSE,
	AUDIO_PLAY_BUSY,
	AUDIO_PLAY_ERROR
} AudioPlayStatus;

/*!
	\brief function pointer type for MIDI lyric event handler\n
	\brief first parameter is channel number (always 15)\n
	\brief second parameter is number of bytes of the lyric\n
	\brief thrid parameter is the lyric itself, be careful there is NO null character at the end
*/
typedef void (*AudioMidiLyricEventHandler)(int /*channel*/, int /*size*/, const char* /*lyric*/);

/*!
	\brief interface of a MIDI data source
*/
typedef struct AudioMidiStream {
	int (*mAudioMidiStreamRead)(unsigned char*, unsigned, struct AudioMidiStream*);
	void (*mAudioMidiStreamReset)(struct AudioMidiStream*);
	void* mExtra;
} AudioMidiStream;

/*!
	\brief function pointer type for MIDI decoder read data source other from memory
	\brief first parameter is buffer for storing data from data source
	\brief second parameter is number of bytes to be read
	\brief third parameter is the stream itself
	\brief return > 0 for number of bytes actually read or < 0 for error
*/
typedef int (*AudioMidiStreamRead)(unsigned char* /*buffer*/, unsigned /*len*/, AudioMidiStream* /*this*/);

/*!
	\brief function pointer type for MIDI decoder reset data source
	\brief first parameter is the stream itself
*/
typedef void (*AudioMidiStreamReset)(AudioMidiStream* /*this*/);

/*!
	\fn void Audio_init(void (*delay_fn)(unsigned), unsigned dac_output, unsigned total_channel_count, unsigned midi_channel_count, int stream_count)
	\brief initialize SPU module and driver and reserve certain amount of channel to MIDI decoder
	\param total_channel_count maximum number of channel enabled for both wave and MIDI playback (0 - 32)
	\param midi_channel_count number of channel reserve to MIDI decoder (0 - total_channel_count)
	\param stream_count number of stream allocate, each stream will consume 2 physical channels and 256kB chunk memory (128kB extra chunk memory will be used to make sure working buffer for stream is 128kB aligned
*/
void Audio_init(unsigned total_channel_count, unsigned midi_channel_count, int stream_count);

/*!
	\fn void Audio_cleanup()
	\brief cleanup SPU module and driver
	\param void
*/
void Audio_cleanup(void);

/*!
	\fn unsigned Audio_getMasterVolume()
	\brief get the master volume for all channels
	\param void
	\return master volume of all channels
*/
unsigned Audio_getMasterVolume(void);

/*!
	\fn void Audio_setMasterVolume(unsigned vol)
	\brief set the master volume for all channels
	\param vol master volume [0 - 127], default 127
*/
void Audio_setMasterVolume(unsigned vol);

/*!
	\fn void Audio_setWave(int channel_id, unsigned char* pcm_data)
	\brief initialize a channel to playback PCM data
	\param channel_id target channel
	\param pcm_data PCM data generated by tools
*/
void Audio_setWave(int channel_id, unsigned char* pcm_data);

/*!
	\fn void Audio_setDrumNote(int channel_id, int drum_idx)
	\brief initialize a channel to playback a drum note from wave table,\n
	\brief other PCM playback related functions such as Audio_setWaveVolume(int, int) can also be used to apply to the playback
	\param channel_id target channel, MUST use non-MIDI channels
	\param drum_idx index of drum tone color in wave table
*/
void Audio_setDrumNote(int channel_id, int drum_idx);

/*!
	\fn void Audio_setMelodyNote(int channel_id, int melody_idx, int pitch, int always_on)
	\brief initialize a channel to playback a melody note from wave table.\n
	\brief other PCM playback related functions such as Audio_setWaveVolume(int, int) can also be used to apply to the playback
	\param channel_id target channel, MUST use non-MIDI channels
	\param melody_idx index of melody tone color in wave table
	\param pitch pitch of playback
	\param keep_on 1 for keeping the tone color playing (i.e. not follow the envelop), 0 for playback the tone color normally (i.e. follow the envelop)
*/
void Audio_setMelodyNote(int channel_id, int melody_idx, int pitch, int keep_on);

/*!
	\fn void Audio_releaseMelodyNote(int channel_id, int fast_ramp_down)
	\brief initialize a channel to release the melody playback
	\param channel_id target channel
	\param fast_ramp_down 1 for ramp down the playback quickly, 0 for ramp down normally (i.e. follow the envelope)
*/
void Audio_releaseMelodyNote(int channel_id, int fast_ramp_down);

/*!
	\fn void Audio_resetWave(int channel_id)
	\brief reset the channel to playback the same PCM again
	\param channel_id target channel
*/
void Audio_resetWave(int channel_id);

/*!
	\fn void Audio_pauseWave(int channel_id)
	\brief pause the PCM playback at specified channel
	\param channel_id target channel
*/
void Audio_pauseWave(int channel_id);

/*!
	\fn void Audio_resumeWave(int channel_id)
	\brief resume a paused PCM playback at specified channel
	\param channel_id target channel
*/
void Audio_resumeWave(int channel_id);

/*!
	\fn AudioPlayStatus Audio_getWaveStatus(int channel_id)
	\brief get the playback status of specified channel
	\param channel_id target channel
	\return playback status
*/
AudioPlayStatus Audio_getWaveStatus(int channel_id);

/*!
	\fn int Audio_isWaveLoopEnable(int channel_id)
	\brief check if looped playback is enabled
	\param channel_id target channel
	\return 1 if looped playback is enabled or otherwise 0
*/
int Audio_isWaveLoopEnable(int channel_id);

/*!
	\fn void Audio_enableWaveLoop(int channel_id, int enable)
	\brief enable/ disable PCM loop playback
	\param channel_id target channel
	\param enable 1 for enable loop playback, 0 for disable loop playback
*/
void Audio_enableWaveLoop(int channel_id, int enable);

/*!
	\fn int Audio_getWaveVolume(int channel_id)
	\brief get the channel volume
	\param channel_id target channel
	\return channel volume
*/
int Audio_getWaveVolume(int channel_id);

/*!
	\fn void Audio_setWaveVolume(int channel_id, int vol)
	\brief set the channel volume
	\param channel_id target channel
	\param vol channel volume [0-127], default 127
*/
void Audio_setWaveVolume(int channel_id, int vol);

/*!
	\fn int Audio_getWavePan(int channel_id)
	\brief get the channel pan
	\param channel_id target channel
	\return channel pan
*/
int Audio_getWavePan(int channel_id);

/*!
	\fn void Audio_setWavePan(int channel_id, int pan)
	\brief set the channel pan
	\param channel_id target channel
	\param pan channel pan [0-127], default 64,\n 64 means center position, 0 means only left, 127 mean only right
*/
void Audio_setWavePan(int channel_id, int pan);

/*!
	\fn unsigned Audio_getWavePlaybackSpeed(int channel_id)
	\brief get the channel playback speed
	\param channel_id target channel
	\param channel playback speed
*/
unsigned short Audio_getWavePlaybackSpeed(int channel_id);

/*!
	\fn void Audio_setWavePlaybackSpeed(int channel_id, unsigned short speed)
	\brief set the channel playback speed
	\param channel_id target channel
	\param speed channel playback speed, default 0x10,\n it is a 4:4 unsigned fix point number which represents the speed up factor to the playback speed
*/
void Audio_setWavePlaybackSpeed(int channel_id, unsigned short speed);

// removed due to noise happened when there is audio playback (in any channel)
///*!
//	\fn unsigned Audio_getWaveCurrentPlayTime(int channel_id)
//	\brief get the time elasped for PCM playback according to PCM data (<= physical time)
//	\param channel_id target channel
//	\return number of ms elasped for PCM playback (reset when playback looped)
//*/
//unsigned Audio_getWaveCurrentPlayTime(int channel_id);

/*!
	\fn void Audio_initMidi(unsigned char* melody_table, unsigned char* drum_table, unsigned max_update_period_in_ms)
	\brief initialize wave table for MIDI decoder
	\param melody_table data pointer to melody instrument wave table
	\param drum_table data pointer to precussion instrument wave table
	\param max_update_period_in_ms maximum amount of time for MIDI decoder to update its status
*/
void Audio_initMidi(unsigned char* melody_table, unsigned char* drum_table, unsigned max_update_period_in_ms);

/*!
	\fn void Audio_cleanupMidi()
	\brief stop MIDI decoder
	\param void
*/
void Audio_cleanupMidi(void);

/*!
	\fn void Audio_setMidi(unsigned char* midi_data, unsigned midi_data_size)
	\brief initialize reserved channel(s) for MIDI playback
	\param midi_data MIDI data generated by tools
	\param midi_data_size MIDI data size, 0 means no size limitation check
*/
void Audio_setMidi(unsigned char* midi_data, unsigned midi_data_size);

/*!
	\fn void Audio_setMidiStream(AudioMidiStream* midi_stream)
	\brief initialize reserved channel(s) for MIDI stream playback
	\param midi_stream MIDI data stream
*/
void Audio_setMidiStream(AudioMidiStream* midi_stream);

/*!
	\fn void Audio_resetMidi()
	\brief reset the reserved channel(s) to playback the same MIDI
	\param void
*/
void Audio_resetMidi(void);

/*!
	\fn void Audio_pauseMidi()
	\brief pause current MIDI playback
	\param void
*/
void Audio_pauseMidi(void);

/*!
	\fn void Audio_resumeMidi()
	\brief resume a paused MIDI playback
	\param void
*/
void Audio_resumeMidi(void);

/*!
	\fn AudioPlayStatus Audio_getMidiStatus()
	\brief check the playback status of MIDI
	\param void
	\return MIDI playback status
*/
AudioPlayStatus Audio_getMidiStatus(void);

/*!
	\fn int Audio_isMidiLoopEnable()
	\brief check if the MIDI playback is looped
	\param void
	\return 1 if the MIDI playback is looped or otherwise 0
*/
int Audio_isMidiLoopEnable(void);

/*!
	\fn void Audio_enableMidiLoop(int loop)
	\brief enable/ disable looped MIDI playback
	\param loop 1 for enable looped playback, 0 for disable looped playback
*/
void Audio_enableMidiLoop(int loop);

/*!
	\fn int Audio_getMidiVolume()
	\brief get the MIDI playback volume
	\param void
	\return MIDI playback volume
*/
int Audio_getMidiVolume(void);

/*!
	\fn void Audio_setMidiVolume(int vol)
	\brief set the MIDI playback volume [0-127], default 127.\n
	\brief please note that the new volume setting may not take effect immediately during playback.\n
	\brief the volume setting will ONLY affect the notes played afterward.
	\param vol MIDI playback volume
*/
void Audio_setMidiVolume(int vol);

/*!
	\fn int Audio_getMidiGlobalPan()
	\brief get the global pan of MIDI playback
	\param void
	\return pan of MIDI playback
*/
int Audio_getMidiGlobalPan(void);

/*!
	\fn void Audio_setMidiGlobalPan(int pan)
	\brief set the global pan of MIDI playback
	\param pan pan of MIDI playback  [0-127], default 64,\n 64 means center position, 0 means only left, 127 mean only right
*/
void Audio_setMidiGlobalPan(int pan);

/*!
	\fn void Audio_enableMidiGlobalPan(int enable)
	\brief enable/ disbale global pan of MIDI playback,\n
	\brief if global pan is enabled, the note pan will be ignored.\n
	\brief if global pan is disabled, note pan will be used instead.\n
	\brief please note that the enable/ disable effect may not take effect immediately during playback.\n
	\brief the global pan setting (enable/ disable, global pan value) will ONLY affect the notes played afterward.
	\param enable 1 for enable global pan, 0 for disable global pan
*/
void Audio_enableMidiGlobalPan(int enable);

/*!
	\fn int Audio_getMidiInstrumentVolume(int ins_type, int ins_idx)
	\brief get the MIDI instrument playback volume
	\param ins_type MIDI instrument type, 0 for MELO type, 1 for DRUM type
	\param ins_idx MIDI instrument index
	\return MIDI instrument playback volume
*/
int Audio_getMidiInstrumentVolume(int ins_type, int ins_idx);

/*!
	\fn void Audio_setMidiInstrumentVolume(int ins_type, int ins_idx, int vol)
	\brief set the MIDI instrument playback volume [0-127], default 127.\n
	\brief please note that the new volume setting may not take effect immediately during playback.\n
	\brief the volume setting will ONLY affect the notes played afterward.
	\param ins_type MIDI instrument type, 0 for MELO type, 1 for DRUM type
	\param ins_idx MIDI instrument index
	\param vol MIDI instrument playback volume
*/
void Audio_setMidiInstrumentVolume(int ins_type, int ins_idx, int vol);

/*!
	\fn unsigned Audio_getMidiCurrentPlayTime()
	\brief get the time elasped for MIDI playback according to MIDI data (<= physical time)
	\return number of ms elasped for MIDI playback (reset when playback looped)
*/
unsigned Audio_getMidiCurrentPlayTime(void);

/*!
	\fn unsigned short Audio_getMidiPlaybackSpeed()
	\brief get the MIDI playback speed
	return MIDI playback speed
*/
unsigned short Audio_getMidiPlaybackSpeed(void);

/*!
	\fn void Audio_setMidiPlaybackSpeed(unsigned short speed)
	\brief set the MIDI playback speed, this setting has no effect to drum instruments and ramp-down melody instruments
	\param speed MIDI playback speed, default 0x10,\n it is a 4:4 unsigned fix point number which represents the speed up factor to the playback speed, the maximum is AUDIO_MAX_MIDI_PLAYBACK_SPEED such that number of interrupt generated by MIDI decoder will not be too much
*/
void Audio_setMidiPlaybackSpeed(unsigned short speed);

/*!
	\fn void Audio_fadeMidi(int fade_in, int fade_duration)
	\brief perform fade in/ out effect for MIDI playback, the fade effect will be stopped once the fade in/ out is completed OR the MIDI is reset OR new MIDI is set.\n
	\brief the fade setting will be set to new setting (and take effect) even the old fading has not finished
	\param fade_direction 1 for fade in effect, -1 for fade out effect, 0 for stop fade effect (immediately)
	\param fade_duration playtime (ms) for the fade effect to complete
*/
void Audio_fadeMidi(int fade_direction, int fade_duration);

/*!
	\fn int Audio_isFadeMidi()
	\brief check if fading is still executing
	\return 1 if fading is still executing or otherwise 0
*/
int Audio_isMidiFade(void);

/*!
	\fn void Audio_setMidiLyricEventHandler(AudioMidiLyricEventHandler handler)
	\brief set lyric event handler to handle lyric events happened during MIDI playback, since the handle was called during beat counter interrupt, it should not take too long to return
	\param handler lyric event handler
*/
void Audio_setMidiLyricEventHandler(AudioMidiLyricEventHandler handler);

/*!
	\fn void Audio_handleBeatCounter()
	\brief beat counter ISR, application need to hook this ISR to system for MIDI playback
	\param void
*/
void Audio_handleBeatCounter(void);

/*!
	\def MAX_AUDIO_STREAM
	\brief maximum number of audio stream can be allocated
*/
#define MAX_AUDIO_STREAM 8

/*!
	\brief input format of audio stream
*/
typedef struct {
	int mSampleSize; /*!< number of bit per sample, MUST be 16 (signed) */
	int mSamplingFrequency;  /*!< sampling frequency */
	int mChannel; /*!< number of channels, 1 for mono and 2 for stereo */
} AudioStreamInputParam;

/*!
	\fn int Audio_allocStream(void)
	\brief allocate an audio stream
	\return handle to audio stream
*/
int Audio_allocStream(void); 

/*!
	\fn Audio_freeStream(int handle)
	\brief free audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
*/
void Audio_freeStream(int handle);

/*!
	\fn int Audio_openStream(int handle, AudioStreamInputParam* param)
	\brief open audio stream for specified format
	\param handle handle to audio stream by Audio_allocStream(void)
	\param param input data format
	\return 0 if operation succeed or otherwise -1
*/
int Audio_openStream(int handle, AudioStreamInputParam* param);

/*!
	\fn void Audio_closeStream(int handle)
	\brief close audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
*/
void Audio_closeStream(int handle);

/*!
	\fn int Audio_resetStream(int handle)
	\brief reset counter and status of audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\return 0 if operation succeed or otherwise -1
*/
int Audio_resetStream(int handle);

/*!
	\fn int Audio_pauseStream(int handle)
	\brief pause playback on audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\return 0 if operation succeed or otherwise -1
*/
int Audio_pauseStream(int handle);

/*!
	\fn int Audio_resumeStream(int handle)
	\brief resume playback on audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\return 0 if operation succeed or otherwise -1
*/
int Audio_resumeStream(int handle);

/*!
	\fn Audio_getStreamVolume(int handle)
	\brief get current playback volume of audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\return volume (>= 0) of audio stream or -1 if operation failed
*/
int Audio_getStreamVolume(int handle);

/*!
	\fn int Audio_setStreamVolume(int handle, int vol)
	\brief set playback volume of audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\param vol playback volume of audio stream
	\return 0 if operation succeed or otherwise -1
*/
int Audio_setStreamVolume(int handle, int vol);

/*!
	\fn AudioPlayStatus Audio_getStreamPlayStatus(int handle)
	\brief get current status of audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\return play status of audio stream
*/
AudioPlayStatus Audio_getStreamPlayStatus(int handle);

/*!
	\fn int Audio_getStreamPlayPos(int handle)
	\brief get (approximate) play position of audio stream, Audio_resetStream(int) or Audio_openStream(int, AudioStreamInputParam*) will reset this counter
	\param handle handle to audio stream by Audio_allocStream(void)
	\return (approximate) play position of audio stream
*/
int Audio_getStreamPlayPos(int handle);

/*!
	\fn int Audio_isStreamFull(int handle)
	\brief check if audio stream is full
	\param handle handle to audio stream by Audio_allocStream(void)
	\return 1 if audio stream is full or otherwise 0
*/
int Audio_isStreamFull(int handle);

/*!
	\fn int Audio_isStreamEmpty(int handle)
	\brief check if audio stream is empty
	\param handle handle to audio stream by Audio_allocStream(void)
	\return 1 if audio stream is empty or otherwise 0
*/
int Audio_isStreamEmpty(int handle);

/*!
	\fn int Audio_fillStreamData(int handle, unsigned short* data, int data_size_in_byte
	\brief fill data to audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\param data data to be filled to audio stream
	\param data_size_in_byte data size in byte
	\return number of bytes actually filled to audio stream (>= 0) or -1 if operation failed
*/
int Audio_fillStreamData(int handle, unsigned short* data, int data_size_in_byte);

/*!
	\fn int Audio_getStreamFreeSize(int handle)
	\brief get (approx.) maximum number of bytes can be filled to audio stream
	\param handle handle to audio stream by Audio_allocStream(void)
	\return (approx.) maximum number of bytes can be filled to audio stream (>= 0) or -1 if operation failed
*/
int Audio_getStreamFreeSize(int handle);

/*!
	\fn void Audio_enableStreamStereo(int enable)
	\brief enable stereo output mode (default is enabled)
	\param enable 1 for enable stereo output, 0 for mono output
*/
void Audio_enableStreamStereo(int enable);

/*!
	\fn Audio_handleFiq(int channel)
	\brief ISR to handle FIQ of SPU
	\param channel index of channel which FIQ occurred 
*/
void Audio_handleFiq(int channel);











#ifdef __cplusplus
}
#endif

#endif
