#ifndef SPUDRV_H
#define SPUDRV_H

#ifdef __cplusplus
extern "C" {
#endif

#include "WaveInfo.h"

/*!
	\brief total number of channel available for playback
*/
#define D_SPU_TOTAL_CHANNEL 32

/*!
	\brief definition for the representation of speed factor == 1
*/
#define D_SPEED_FACTOR_ONE 0x0100

/*!
	\brief definition for the representation of minimum speed factor == 1/16
*/
#define D_SPEED_MIN_FACTOR 0x0010

/*!
	\brief definition for the representation of maximum speed factor == 2
*/
#define D_SPEED_MAX_FACTOR 0x0200

/*!
	\brief definition of audio data format
*/
#define D_FORMAT_ATTACK_PCM8_LOOP_PCM8			0x0
#define D_FORMAT_ATTACK_PCM16_LOOP_PCM16		0x1
#define D_FORMAT_ATTACK_ADPCM_LOOP_PCM8			0x2
#define D_FORMAT_ATTACK_ADPCM_LOOP_PCM16		0x3
#define D_FORMAT_ATTACK_ADPCM36_LOOP_PCM8		0x4
#define D_FORMAT_ATTACK_ADPCM36_LOOP_PCM16		0x5
#define D_FORMAT_ATTACK_ADPCM36_LOOP_ADPCM36	0x6

#define D_OUTPUT_CHANNEL_HEADPHONE_R 0x10
#define D_OUTPUT_CHANNEL_HEADPHONE_L 0x20
#define D_OUTPUT_CHANNEL_LINEOUT_R 0x40
#define D_OUTPUT_CHANNEL_LINEOUT_L 0x80

/*!
	\brief factor applies to sampling rate
*/
#define D_BASEPHASE (0x1D208L/8) // ((2^19)/288k) = 1.820, represents as 8:13 fix point number
#define SAMPLERATE_2_PHASE(sample_rate) ((sample_rate == 18000)? 0x8000 : ((sample_rate * D_BASEPHASE + 0x00001fff) >> (16-3)))
#define PHASE_2_SAMPLERATE(phase) ((phase << (16-3)) / D_BASEPHASE)

/*!
	\brief function pointer type used to handle beat counter interrupt
*/
typedef void (*SpuBeatCntHandler)(void);

/*!
	\brief function pointer type used to handle FIQ\n
	\brief first param is the channel index where the FIQ happened
*/
typedef void (*SpuFiqHandler)(int);

/*!
	\fn void Spu_init()
	\brief initialize SPU module and driver
*/
void Spu_init(void);

/*!
	\fn void Spu_cleanup()
	\brief cleanup SPU module and driver
	\param void
*/
void Spu_cleanup(void);

/*!
	\fn int Spu_getMasterVolume()
	\brief get the master volume for all channels
	\param void
	\return master volume of all channels
*/
unsigned Spu_getMasterVolume(void);

/*!
	\fn void Spu_setMasterVolume(int vol)
	\brief set the master volume for all channels
	\param vol master volume [0 - 127], default 127
*/
void Spu_setMasterVolume(unsigned vol);

/*!
	\fn void Spu_setWave(int channel_id, unsigned char* pcm_data)
	\brief initialize a channel to playback PCM data
	\param channel_id target channel
	\param pcm_data PCM data generated by tools
*/
void Spu_setWave(int channel_id, unsigned char* pcm_data);

/*!
	\fn void Spu_setWaveEx(int channel_id, const WaveInfo* info)
	\brief initialize a channel to playback PCM data (with more configuration)
	\param channel_id target channel
	\param info information used to configure the channel
*/
void Spu_setWaveEx(int channel_id, const WaveInfo* info);

/*!
	\fn void Spu_resetWave(int channel_id)
	\brief reset the channel to playback the same PCM again, this function ONLY works for the PCM data setup by Spu_setWave(int, unsigned char*)
	\param channel_id target channel
*/
void Spu_resetWave(int channel_id);

/*!
	\fn void Spu_pauseWave(int channel_id)
	\brief pause the PCM playback at specified channel
	\param channel_id target channel
*/
void Spu_pauseWave(int channel_id);

/*!
	\fn void Spu_pauseWaves(unsigned start_idx, unsigned end_idx)
	\brief pause PCM playback at specified range of channels.\n
	\brief unlike Spu_pauseWave(), this function will not check if the channel was paused before suspending the channel.\n
	\brief therefore, PCM playback may not able to resume if channel was being paused twice
	\param start_idx start channel
	\param end_idx end channel
*/
void Spu_pauseWaves(unsigned start_idx, unsigned end_idx);

/*!
	\fn void Spu_resumeWave(int channel_id)
	\brief resume a paused PCM playback at specified channel
	\param channel_id target channel
*/
void Spu_resumeWave(int channel_id);

/*!
	\fn void Spu_resumeWaves(unsigned start_idx, unsigned end_idx)
	\brief resume paused PCM playback at specified range of channels
	\param start_idx start channel
	\param end_idx end channel
*/
void Spu_resumeWaves(unsigned start_idx, unsigned end_idx);

/*!
	\fn void Spu_stopWave(int channel_id)
	\brief stop a PCM playback at specified channel, a stopped playback cannot be resumed (unless reset)
	\param channel_id target channel
*/
void Spu_stopWave(int channel_id);

/*!
	\fn void Spu_stopWaves(unsigned channel_maskLH, unsigned channel_maskX)
	\brief stop PCM playback at specified range of channels, stopped playback(s) cannot be resumed (unless reset)
	\param start_idx start channel
	\param end_idx end channel
*/
void Spu_stopWaves(unsigned start_idx, unsigned end_idx);

/*!
	\fn int Spu_isWaveLoopEnable(int channel_id)
	\brief check if looped playback is enabled
	\param channel_id target channel
	\return 1 if looped playback is enabled or otherwise 0
*/
int Spu_isWaveLoopEnable(int channel_id);

/*!
	\fn void Spu_enableWaveLoop(int channel_id, int enable)
	\brief enable/ disable PCM loop playback
	\param channel_id target channel
	\param enable 1 for enable loop playback, 0 for disable loop playback
*/
void Spu_enableWaveLoop(int channel_id, int enable);

/*!
	\fn int Spu_getWaveVolume(int channel_id)
	\brief get the channel volume
	\param channel_id target channel
	\return channel volume
*/
int Spu_getWaveVolume(int channel_id);

/*!
	\fn void Spu_setWaveVolume(int channel_id, int vol)
	\brief set the channel volume
	\param channel_id target channel
	\param vol channel volume [0-127], default 127
*/
void Spu_setWaveVolume(int channel_id, int vol);

/*!
	\fn int Spu_getWavePan(int channel_id)
	\brief get the channel pan
	\param channel_id target channel
	\return channel pan
*/
int Spu_getWavePan(int channel_id);

/*!
	\fn void Spu_setWavePan(int channel_id, int pan)
	\brief set the channel pan
	\param channel_id target channel
	\param pan channel pan [0-127], default 64,\n 64 means center position, 0 means only left, 127 mean only right
*/
void Spu_setWavePan(int channel_id, int pan);

/*!
	\fn unsigned Spu_getWavePlaybackSpeed(int channel_id)
	\brief get the channel playback speed
	\param channel_id target channel
	\param channel playback speed
*/
unsigned short Spu_getWavePlaybackSpeed(int channel_id);

/*!
	\fn void Spu_setWavePlaybackSpeed(int channel_id, unsigned short tempo)
	\brief set the channel playback speed
	\param channel_id target channel
	\param speed channel playback speed, default 0x10,\n it is a 4:4 unsigned fix point number which represents the speed up factor to the playback speed
*/
void Spu_setWavePlaybackSpeed(int channel_id, unsigned short speed);

/*!
	\fn unsigned Spu_getWavePhase(int channel_id)
	\brief get the phase value of specified channel
	\param channel_id target channel
	\return phase value
*/
unsigned Spu_getWavePhase(int channel_id);

/*!
	\fn unsigned Spu_setWavePhase(int channel_id)
	\brief set the phase value of specified channel
	\param channel_id target channel
	\param phase phase value (sampling frequency * 0x1d2 / 256)
*/
void Spu_setWavePhase(int channel_id, unsigned phase);

/*!
	\fn int Spu_isWavePlaying(int channel_id)
	\brief check if wave is playing in specified channel
	\param channel_id target channel
	\return 1 if channel is playing or otherwise 0
*/
int Spu_isWavePlaying(int channel_id);

/*!
	\fn int Spu_isWavePause(int channel_id)
	\brief check if wave is paused in specified channel
	\param channel_id target channel
	\return 1 if channel is paused or otherwise 0
*/
int Spu_isWavePause(int channel_id);

/*!
	\fn int Spu_isWaveStop(int channel_id)
	\brief check if wave is stopped (not paused and not playing) in specified channel
	\param channel_id target channel
	\return 1 if channel if stopped or otherwise 0
*/
int Spu_isWaveStop(int channel_id);

/*!
	\fn void Spu_enableFiq(int channel_id)
	\brief enable/ disable FIQ of specified channel (loop play mode MUST enable in order to trigger FIQ)
	\param channel_id target channel
	\param enable 1 for enable FIQ of specified channel 0 for disable FIQ of specified channel
*/
void Spu_enableFiq(int channel_id, int enable);

/*!
	\fn int Spu_isFiqEnable(int channel_id)
	\brief check if specified channel enabled FIQ
	\param channel_id target channel
	\return 1 if FIQ enabled in specified channel or otherwise 0
*/
int Spu_isFiqEnable(int channel_id);

/*!
	\fn int Spu_getFiqStatus(int channel_id)
	\brief check the FIQ status of specified channel
	\param channel_id target channel
	\return 1 if FIQ happened in specified channel or otherwise 0
*/
int Spu_getFiqStatus(int channel_id);

/*!
	\fn void Spu_clearFiqStatus(int channel_id)
	\brief clear FIQ status of specified channel
	\param channel_id target channel
*/
void Spu_clearFiqStatus(int channel_id);

/*!
	\fn void Spu_setBeatCntHandler(SpuBeatCntHandler handler)
	\brief set beat counter interrupt handler
	\param handler function pointer to beat counter interrupt service routine
*/
void Spu_setBeatCntHandler(SpuBeatCntHandler handler);

/*!
	\fn void Spu_setFiqHandler(int channel, SpuFiqHandler handler)
	\brief set FIQ handler
	\param channel_id target channel
	\param handler function pointer to FIQ service routine
*/
void Spu_setFiqHandler(int channel_id, SpuFiqHandler handler);

/*!
	\fn void Spu_BeatCntIsr()
	\brief entry point for system to callback when beat count interrupt occurred (detected).\n
	\brief this function will then callback application SpuBeatCntHandler
	\param void
*/
void Spu_BeatCntIsr(void);

/*!
	\fn void Spu_FiqIsr()
	\brief entry point for system to callback when FIQ occurred (detected).\n
	\brief this function will then callback application SpuFiqHandler
*/
void Spu_FiqIsr(void);

// pls try the following functions as Ge+ claimed that it is fine to read SPU registers when there is channel(s) playing audio

/*!
	\fn unsigned Spu_getWaveCurrentPlayTime(unsigned channel_id)
	\brief get the time elasped for PCM playback according to PCM data (<= physical time)
	\param channel_id target channel
	\return number of ms elasped for PCM playback (reset when playback looped)
*/
unsigned Spu_getWaveCurrentPlayTime(unsigned channel_id);

/*!
	\fn unsigned Spu_getWaveAddr(unsigned channel_id)
	\brief get the current wave data address
	\param channel_id target channel
	\return current wave address
*/
unsigned Spu_getWaveAddr(unsigned channel_id);

// pls try the following functions as Ge+ claimed that it is safe to write loop address when corresponding channel is playing audio

/*!
	\fn void Spu_setLoopAddress(int channel_idx, unsigned char* addr)
	\brief set loop address for PCM playback, can be used in FIQ handler for the purpose of streaming audio implementation
	\param channel_id target channel
	\param addr loop address
*/
void Spu_setLoopAddress(int channel_id, unsigned char* addr);

unsigned Spu_getLoopAddr(unsigned channel_id);

#ifdef __cplusplus
}
#endif

#endif
